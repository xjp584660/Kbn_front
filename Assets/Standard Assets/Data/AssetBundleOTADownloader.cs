// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System;

namespace KBN
{
	public class AssetBundleOTADownloader : MonoBehaviour
	{

		//-----------------------------------------------------------------------------------
		// Public interfaces
		//-----------------------------------------------------------------------------------

		// Asset bundle state
		public enum AssetBundleState
		{
			ASSET_BUNDLE_STATE_NETWORK_ERROR = 0,
			ASSET_BUNDLE_STATE_QUERY_IN_PROGRESS,
			ASSET_BUNDLE_STATE_NOT_EXIST_ON_DEVICE,
			ASSET_BUNDLE_STATE_UP_TO_DATE,
			ASSET_BUNDLE_STATE_OUT_OF_DATE,
			ASSET_BUNDLE_STATE_DOWNLOAD_IN_PROGRESS,
			ASSET_BUNDLE_STATE_NOT_EXIST_ON_SERVER,
		};
		
		public enum DownloadState
		{
			DOWNLOAD_STATE_NETWORK_ERROR = 0,
			DOWNLOAD_STATE_IN_PROGRESS,
			DOWNLOAD_STATE_DOWNLOAD_COMPLETE,
			DOWNLOAD_STATE_CHECKSUM_ERROR,
			DOWNLOAD_STATE_NOT_EXIST_ON_SERVER,
		};

		/**
		 * The singleton getter
		 */
		public static AssetBundleOTADownloader instance() { return singleton; }

		/**
		 * Query the state of an asset bundle.
		 * 
		 * The query is performed in an asynchornized manner.
		 */
		public void queryAssetBundleState( string assetBundleName, MulticastDelegate stateQueryCallback )
		{
			m_imp.queryAssetBundleState( assetBundleName, stateQueryCallback );
		}

		/**
		 * Download an asset bundle
		 * 
		 * The download state can be queried in an asynchronized manner.
		 */
		public void subscribeDownloadProgress( string assetBundleName, MulticastDelegate downloadProgressCallback,
		                                      bool replaceCallbackIfAlreadyExists )
		{
			m_imp.subscribeDownloadProgress( assetBundleName, downloadProgressCallback, replaceCallbackIfAlreadyExists );
		}

		/**
		 * Retrieve asset from the asset bundle
		 * 
		 * 
		 */
		public object retrieveAsset( string assetName, string assetBundleKey )
		{
			return m_imp.retrieveAsset( assetName, assetBundleKey );
		}

		/**
		 * Release the asset bundle
		 * 
		 * 
		 */
		public void releaseAssetBundle( string assetBundleKey )
		{
			m_imp.releaseAssetBundle( assetBundleKey );
		}

		/**
		 * Release all the asset bundles from the cache
		 * 
		 * 
		 */
		public void releaseAllAssetBundles()
		{
			m_imp.releaseAllAssetBundles();
		}

		/**
		 * Filter the OTA list in the startup state of the game. 
		 * 
		 * Some of the asset bundles will be updated 
		 * 
		 */
		public HashObject filterAssetBundleListOnGameStart( HashObject atoList )
		{
			return m_imp.filterAssetBundleListOnGameStart( atoList );
		}

		/**
		 * OTA utility condition check
		 * 
		 * 
		 * 
		 */
		public bool isSupportingOTAOnThisDevice()
		{
			if( Application.platform == RuntimePlatform.IPhonePlayer )
				return true;
			return false;
		}
		/**
		 * Check the asset bundle existence
		 * 
		 * 
		 * 
		 */
		public bool checkAssetBundleExistenceOnServer( string assetBundle )
		{
			return m_imp.checkAssetBundleExistenceOnServer( assetBundle );
		}

		/**
		 * Set the owner of this object
		 * 
		 * 
		 * 
		 */
		public void setOwner( GameMain owner )
		{
			m_imp.setOwner( owner );
		}


		// Expose the implementations to the inspector to assign
		public AssetBundleOTADownloaderImp_Legacy m_impLegacy;
		public AssetBundleOTADownloaderImp_Cached m_impCached;



		//-----------------------------------------------------------------------------------
		// Underlying implementations
		//-----------------------------------------------------------------------------------
		private static AssetBundleOTADownloader singleton;
		private static bool USING_LEGACY_IMPLEMENTATION = true;
		private AssetBundleOTADownloaderImp_Base m_imp;

		public void Awake()
		{
			singleton = this;
if( USING_LEGACY_IMPLEMENTATION ) {
			m_imp = m_impLegacy;
} else {
			m_imp = m_impCached;
}
		}
	}
}