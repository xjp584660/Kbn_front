// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using UnityEngine;
namespace KBN
{
	// AssetBundleManager_Deprecate is a facade class that simplifies the usage
	// of the AssetBundleOTADownloader class.
	public class AssetBundleManager_Deprecate : MonoBehaviour
	{

		//-----------------------------------------------------------------------------------
		// Public interfaces
		//-----------------------------------------------------------------------------------

		public enum RetrieveResult
		{
			RETRIEVE_RESULT_SUCCEEDED = 0,
			RETRIEVE_RESULT_DOWNLOAD_IN_PROGRESS,
			RETRIEVE_RESULT_NETWORK_ERROR,
			RETRIEVE_RESULT_NOT_EXIST_ON_SERVER,
		};

		/**
		 * Check the asset bundle existence
		 * 
		 **/
		public bool checkAssetBundleExistenceOnServer( string assetBundleName )
		{
			return m_downloader.checkAssetBundleExistenceOnServer( assetBundleName );
		}

		/**
		 * Retrieve a specified asset from the asset bundle in an asynchronized manner
		 * 
		 **/
		public void retrieveAsset( string assetName, string assetBundleFileName, bool releaseAssetBundleAfterLoad,
		                          MulticastDelegate subscriberHandle )
		{
			string[] names = new string[1];
			names[0] = assetName;
			retrieveAssets( names, assetBundleFileName, releaseAssetBundleAfterLoad,
			               subscriberHandle );
		}
		/**
		 * Retrieve multiple specified assets from the asset bundle in an asynchronized manner
		 * 
		 **/
		public void retrieveAssets( string[] assetNames, string assetBundleFileName, bool releaseAssetBundleAfterLoad,
		                           MulticastDelegate subscriberHandle )
		{
			RetrieveApplication app = new RetrieveApplication();
			app.m_releaseAssetBundleAfterLoad = releaseAssetBundleAfterLoad;
			app.m_assetNames = assetNames;
			app.m_assetBundleFileName = assetBundleFileName;
			app.m_subscriberHandle = subscriberHandle;
			m_queue.Enqueue( app );
		}

		/**
		 * Release all asset bundles from the cache
		 * 
		 * If the user didn't set the asset bundle to be released after loading assets in
		 * the retrieveAsset() call, the asset bundle will be stayed in the cache
		 * to accelerate the visiting for the next time, which would be reserving considerable
		 * memory as the size of the asset bundle is nontrivial. This method could be called
		 * whenever the user thinks the memory is in emergency.
		 * 
		 **/
		public void releaseAssetBundleCache()
		{
			m_downloader.releaseAllAssetBundles();
		}

		// Asset bundle names
		public static string ASSET_BUNDLE_AUDIO = "audio.assetbundle";
		public static string ASSET_BUNDLE_CHAPTERMAP_100 = "chaptermap100.assetbundle";
		public static string ASSET_BUNDLE_CHAPTERMAP_101 = "chaptermap101.assetbundle";
		public static string ASSET_BUNDLE_CHAPTERMAP_102 = "chaptermap102.assetbundle";
		public static string ASSET_BUNDLE_CHAPTERMAP_103 = "chaptermap103.assetbundle";
		public static string ASSET_BUNDLE_CHAPTERMAP_104 = "chaptermap104.assetbundle";
		public static string ASSET_BUNDLE_CHAPTERMAP_105 = "chaptermap105.assetbundle";


		//-----------------------------------------------------------------------------------
		//-----------------------------------------------------------------------------------
		//-----------------------------------------------------------------------------------
		//-----------------------------------------------------------------------------------
		//-----------------------------------------------------------------------------------
		//-----------------------------------------------------------------------------------
		



		//-----------------------------------------------------------------------------------
		// Underlying implementations
		//-----------------------------------------------------------------------------------

		public void Update()
		{
			if( m_handleState == InternalHandleState.STATE_DONE )
			{
				if( m_queue.Count > 0 )
				{
					RetrieveApplication app = m_queue.Peek() as RetrieveApplication;

					m_downloader.queryAssetBundleState( app.m_assetBundleFileName,
					                                   m_queryHandler );
					m_handleState = InternalHandleState.STATE_QUERYING;
				}
			}
		}


		public AssetBundleOTADownloader m_downloader; // Will be assigned via the inspector

		public void Awake()
		{
			m_handleState = InternalHandleState.STATE_DONE;
			m_downloadHandler = onDownloadAssetBundle;
			m_queryHandler = onQueryAssetBundle;
		}

		private enum InternalHandleState
		{
			STATE_QUERYING = 0,
			STATE_DOWNLOADING,
			STATE_DONE,
		};

		private class RetrieveApplication
		{
			public string[] m_assetNames;
			public string m_assetBundleFileName;
			public bool m_releaseAssetBundleAfterLoad;
			public MulticastDelegate m_subscriberHandle;
		};


		private Queue m_queue = new Queue();
		private InternalHandleState m_handleState;
		private delegate void OnDownloadAssetBundle( string assetBundleName,
		                                            AssetBundleOTADownloader.DownloadState downloadState, 
		                                            float progress );
		private delegate void OnQueryAssetBundle( string assetBundleName,
		                                         AssetBundleOTADownloader.AssetBundleState assetBundleState );

		private OnDownloadAssetBundle m_downloadHandler;
		private OnQueryAssetBundle m_queryHandler;

		private void onAssetBundleNotFoundOnServer()
		{
			RetrieveApplication app = m_queue.Dequeue() as RetrieveApplication;
			app.m_subscriberHandle.DynamicInvoke( app.m_assetBundleFileName,
			                                     app.m_assetNames,
			                                     RetrieveResult.RETRIEVE_RESULT_NOT_EXIST_ON_SERVER, null,
			                                     0 );
			m_handleState = InternalHandleState.STATE_DONE;
		}

		private void onDownloadError()
		{
			RetrieveApplication app = m_queue.Dequeue() as RetrieveApplication;
			app.m_subscriberHandle.DynamicInvoke( app.m_assetBundleFileName,
			                                     app.m_assetNames,
			                                     RetrieveResult.RETRIEVE_RESULT_NETWORK_ERROR, null,
			                                     0 );
			m_handleState = InternalHandleState.STATE_DONE;
		}

		private void onAssetGetReady()
		{
			// Get the asset
			RetrieveApplication app = m_queue.Dequeue() as RetrieveApplication;
			string assetBundleKey = TextureMgr.instance().otaPackageNameToType( app.m_assetBundleFileName );
			object[] assets = null;
			if( app.m_assetNames != null )
			{
				assets = new object[app.m_assetNames.Length];
				for( int i = 0; i < assets.Length; ++i )
				{
					object asset = null;
					if( app.m_assetNames[i] != null )
					{
						asset = m_downloader.retrieveAsset( app.m_assetNames[i], assetBundleKey );
					}
					assets[i] = asset;
				}
			}

			if( app.m_releaseAssetBundleAfterLoad )
			{
				m_downloader.releaseAssetBundle( assetBundleKey );
			}
			app.m_subscriberHandle.DynamicInvoke( app.m_assetBundleFileName,
			                                     app.m_assetNames,
			                                     RetrieveResult.RETRIEVE_RESULT_SUCCEEDED, assets, 0.0f );
			m_handleState = InternalHandleState.STATE_DONE;
		}

		private void onDownloadAssetBundle( string assetBundleName,
		                                              AssetBundleOTADownloader.DownloadState downloadState, 
		                                              float progress )
		{
			switch( downloadState )
			{
			case AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_NETWORK_ERROR:
				onDownloadError();
				break;
			case AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_IN_PROGRESS:
				RetrieveApplication app = m_queue.Peek() as RetrieveApplication;
				app.m_subscriberHandle.DynamicInvoke( assetBundleName,
				                                     null,
				                                     RetrieveResult.RETRIEVE_RESULT_DOWNLOAD_IN_PROGRESS,
				                                 null,
				                                 progress );
				break;
			case AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_DOWNLOAD_COMPLETE:
				onAssetGetReady();
				break;
			case AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_NOT_EXIST_ON_SERVER:
				onAssetBundleNotFoundOnServer();
				break;
			}
			
		}
		
		private void onQueryAssetBundle( string assetBundleName,
		                                           AssetBundleOTADownloader.AssetBundleState assetBundleState )
		{
			switch( assetBundleState )
			{
			case AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_QUERY_IN_PROGRESS:
				break;

			case AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NETWORK_ERROR: // Something wrong with the local file
			case AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NOT_EXIST_ON_DEVICE:
			case AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_OUT_OF_DATE:
				m_downloader.subscribeDownloadProgress( assetBundleName, m_downloadHandler,
				                                        true );
				m_handleState = InternalHandleState.STATE_DOWNLOADING;
				break;
			case AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_UP_TO_DATE:
				onAssetGetReady();
				break;
			case AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_DOWNLOAD_IN_PROGRESS:
				break;
			case AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NOT_EXIST_ON_SERVER:
				onAssetBundleNotFoundOnServer();
				break;
			}
		}
	}
}

