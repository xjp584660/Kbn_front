// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using UnityEngine;
namespace KBN
{

public class AssetBundleOTADownloaderImp_Legacy : AssetBundleOTADownloaderImp_Base
{

	/**
	 * Query the state of an asset bundle.
	 * 
	 * The query is performed in an asynchornized manner.
	 */
	public override void queryAssetBundleState( string assetBundleName, MulticastDelegate stateQueryCallback )
	{
		if( USING_INITIAL_ASSET_BUNDLE_LIST )
		{
			if( m_remoteAssetBundle[assetBundleName] == null )
			{
				stateQueryCallback.DynamicInvoke( assetBundleName,
					                 AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NOT_EXIST_ON_SERVER  );
				return;
			}
		}

		if( m_downloadContexts[assetBundleName] != null ) // The download is in progress
		{
			QueryContext qc = m_stateContexts[assetBundleName].Value as QueryContext;
			qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
				                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_DOWNLOAD_IN_PROGRESS,
			                                       0 );
		}
		else if( m_stateContexts[assetBundleName] != null ) // The query is in progress
		{
			QueryContext qc = m_stateContexts[assetBundleName].Value as QueryContext;
			qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
				                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_QUERY_IN_PROGRESS,
			                                       0 );
		}
		else
		{
			QueryContext qc = new QueryContext();
			qc.m_queryResultCallback = stateQueryCallback;
			m_stateContexts[assetBundleName] = new HashObject();
			m_stateContexts[assetBundleName].Value = qc;
			StartCoroutine( "query", assetBundleName );
		}
	}
	/**
	 * Download an asset bundle
	 * 
	 * The download state can be queried in an asynchronized manner.
	 */
	public override void subscribeDownloadProgress( string assetBundleName, MulticastDelegate downloadProgressCallback,
	                                      bool replaceCallbackIfAlreadyExists )
	{
		if( USING_INITIAL_ASSET_BUNDLE_LIST )
		{
			if( m_remoteAssetBundle[assetBundleName] == null )
			{
				downloadProgressCallback.DynamicInvoke( assetBundleName,
					                     AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_NOT_EXIST_ON_SERVER  );
				return;
			}
		}
		if( m_downloadContexts[assetBundleName] == null ) // No download context, start downloading
		{
			DownloadContext dc = new DownloadContext();
			dc.m_downloadResultCallback = downloadProgressCallback;
			dc.m_progress = 0;
			m_downloadContexts[assetBundleName] = new HashObject();
			m_downloadContexts[assetBundleName].Value = dc;
			StartCoroutine( "download", assetBundleName );
		}
		else // The download is in progress
		{
			DownloadContext dc = m_downloadContexts[assetBundleName].Value as DownloadContext;
			downloadProgressCallback.DynamicInvoke( assetBundleName,
				                                       AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_IN_PROGRESS,
			                                       dc.m_progress );
			if( replaceCallbackIfAlreadyExists )
			{
				dc.m_downloadResultCallback = downloadProgressCallback;
			}
		}
	}

	


	//-----------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------



	//-----------------------------------------------------------------------------------
	// Underlying implementation
	//-----------------------------------------------------------------------------------
	class QueryContext
	{
		public MulticastDelegate		m_queryResultCallback;	// Callback to notify the subscriber
		
	};

	class DownloadContext
	{
		public float					m_progress;
		public MulticastDelegate	m_downloadResultCallback;
	};

	

	private HashObject m_stateContexts = new HashObject();
	private HashObject m_downloadContexts = new HashObject();
	

	private static string REMOTE_QUERY_SERVER = "http://www.cmdev6.kabam.asia/ajax/upgrade.php";
	private static bool DEBUG_UPDATE_LOCAL_FILE_ON_COMPLETE = true;

	
	private static bool USING_CRC_CHECKSUM = true;
	

	private IEnumerator query( string assetBundleName )
	{
		QueryContext qc = m_stateContexts[assetBundleName].Value as QueryContext;
		
		string localVer = PlayerPrefs.GetString( assetBundleName, "0" );
		string remoteVer;
		string remoteUrl;
		
		// Query the remote asset bundle
		if( !USING_INITIAL_ASSET_BUNDLE_LIST )
		{
			WWWForm checkingParams = new WWWForm();
			HashObject ver = new HashObject(new System.Collections.Hashtable(){{ assetBundleName, localVer }});
			string json = ver.ToString();
			checkingParams.AddField( "otas", json );
			WWW checkRemote = new WWW( REMOTE_QUERY_SERVER, checkingParams );
			yield return checkRemote;
			
			if( checkRemote.error != null ) // Query error
			{
				qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
					                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NETWORK_ERROR );
				m_stateContexts.Remove( assetBundleName );
				checkRemote.Dispose(); // Dereference web stream and call GC to release WWW
				yield break;
			}
			
			string resultString = checkRemote.text;
			HashObject remoteInfo = JSONParse.instance.Parse( resultString );
			
			string queryResult = _Global.GetString( remoteInfo["ok"] );
			if( queryResult == "False" )
			{
				qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
					                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NETWORK_ERROR );
				m_stateContexts.Remove( assetBundleName );
				checkRemote.Dispose(); // Dereference web stream and call GC to release WWW
				yield break;
			}
			
			remoteVer = _Global.GetString( remoteInfo["ver"] );
			remoteUrl = _Global.GetString( remoteInfo["url"] );
			if( m_remoteAssetBundle[assetBundleName] == null )
			{
				m_remoteAssetBundle[assetBundleName] = new HashObject();
			}
			AssetBundleInfo info = new AssetBundleInfo();
			info.m_url = remoteUrl;
			info.m_version = remoteVer;
			m_remoteAssetBundle[assetBundleName].Value = info;
			checkRemote.Dispose(); // Dereference web stream and call GC to release WWW
		}
		else
		{
			AssetBundleInfo info = m_remoteAssetBundle[assetBundleName].Value as AssetBundleInfo;
			remoteVer = _Global.GetString( info.m_version );
			remoteUrl = _Global.GetString( info.m_url );
		}
		
		if( remoteVer.Equals( localVer ) ) // The file here is up to date
		{
			// Check the asset bundle cache
			string assetBundleKey = TextureMgr.instance().otaPackageNameToType( assetBundleName );
			if( !m_assetBundleCache.ContainsKey( assetBundleKey ) )
			{
				// Check the local file
				string fullPathName = "file:///" + getOTALocalFilePath() + assetBundleName;
				WWW localFile = new WWW( fullPathName );
				yield return localFile;
				
				
				if( localFile.error != null ) // No file found at the local backing store
				{
					qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
						                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NOT_EXIST_ON_DEVICE );
					m_stateContexts.Remove(assetBundleName);
					localFile.Dispose(); // Dereference web stream and call GC to release WWW
					yield break;
				}
				
				AssetBundle assetbundle = localFile.assetBundle;
				
				if( !assetbundle ) // No file found at the local backing store
				{
					qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
						                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_NOT_EXIST_ON_DEVICE );
					m_stateContexts.Remove( assetBundleName );
					localFile.Dispose(); // Dereference web stream and call GC to release WWW
					yield break;
				}
				
				// The file exists
				cacheAssetBundle( assetbundle, assetBundleName );
				
				localFile.Dispose(); // Dereference web stream and call GC to release WWW
			}
			
			qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
				                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_UP_TO_DATE );
			m_stateContexts.Remove( assetBundleName );
			
			yield break;
		}
		else // The file here is out of date, download it anyway
		{
			qc.m_queryResultCallback.DynamicInvoke( assetBundleName,
				                                       AssetBundleOTADownloader.AssetBundleState.ASSET_BUNDLE_STATE_OUT_OF_DATE );
			m_stateContexts.Remove( assetBundleName );
			yield break;
		}
	}

	private bool checksum( AssetBundle assetbundle )
	{
		return true;
	}

	
	private IEnumerator download( string assetBundleName )
	{
		if( m_downloadContexts[assetBundleName] != null )
		{
			AssetBundleInfo info = m_remoteAssetBundle[assetBundleName].Value as AssetBundleInfo;
			WWW download = new WWW( info.m_url );
			HashObject context = new HashObject();
			context["name"] = new HashObject();
			context["download"] = new HashObject();
			context["name"].Value = assetBundleName;
			context["download"].Value = download;
			StartCoroutine( "progress", context );
			yield return download;
			

			StopCoroutine( "progress" );
			DownloadContext dc = m_downloadContexts[assetBundleName].Value as DownloadContext;
			
			if( download.error != null ) // Download error
			{
				dc.m_downloadResultCallback.DynamicInvoke( assetBundleName,
					                                          AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_NETWORK_ERROR, 0 );
			}
			else
			{
				AssetBundle assetbundle = download.assetBundle;
				if( assetbundle != null ) // Download complete
				{
					if( checksum( assetbundle ) )
					{
						cacheAssetBundle( assetbundle, assetBundleName );
						
						// Save the file and update the verion
						if( DEBUG_UPDATE_LOCAL_FILE_ON_COMPLETE )
						{
							System.IO.Stream inputStream = new System.IO.MemoryStream(download.bytes);
//							TextureMgr.instance().CacheAssetBundle( assetBundleName, inputStream );
							PlayerPrefs.SetString( assetBundleName, info.m_version );
						}
						
						dc.m_progress = 1.0f;
						dc.m_downloadResultCallback.DynamicInvoke( assetBundleName,
							                                          AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_IN_PROGRESS,
						                                          1.0f );
						dc.m_downloadResultCallback.DynamicInvoke( assetBundleName,
							                                          AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_DOWNLOAD_COMPLETE,
						                                          1.0f );
						
					}
					else // Checksum error
					{
						dc.m_downloadResultCallback.DynamicInvoke( assetBundleName,
							                                          AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_CHECKSUM_ERROR,
						                                          0 );
					}
				}
			}
			m_downloadContexts.Remove( assetBundleName );
			download.Dispose();
			yield break;
		}
	}

	private IEnumerator progress( HashObject context )
	{
		string assetBundleName = context["name"].Value as string;
		WWW download = context["download"].Value as WWW;
		
		DownloadContext dc = m_downloadContexts[assetBundleName].Value as DownloadContext;
		while( !download.isDone && download.error == null )
		{
			dc.m_downloadResultCallback.DynamicInvoke( assetBundleName,
				                                          AssetBundleOTADownloader.DownloadState.DOWNLOAD_STATE_IN_PROGRESS,
			                                          download.progress );
			dc.m_progress = download.progress;
			yield return 1;
		}
	}
}
}